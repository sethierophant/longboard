#![feature(proc_macro_hygiene)]
#![feature(decl_macro)]
#![feature(never_type)]

#[macro_use]
extern crate diesel;

use std::fmt::Write;
use std::string::ToString;

use derive_more::{Display, From};

use maplit::hashmap;

use rocket::fairing::{Fairing, Info, Kind};
use rocket::http::{Status, StatusClass};
use rocket::{response::Responder, Request, Response, Rocket};

use rocket_contrib::templates::Template;

use log::{error, info, warn};

/// Server configuration.
pub mod config;
/// Data models and database functions.
pub mod models;
/// Routes and request handling.
pub mod routes;
/// Auto-generated by diesel.
pub mod schema;
/// Views and types for rendering.
pub mod views;

use models::{PostId, ThreadId};

/// Our error type.
#[derive(Debug, Display, From)]
pub enum Error {
    #[display(fmt = "Board '{}' not found", board_name)]
    BoardNotFound { board_name: String },
    #[display(fmt = "Thread #{} on board '{}' not found", thread_id, board_name)]
    ThreadNotFound {
        board_name: String,
        thread_id: ThreadId,
    },
    #[display(fmt = "Post #{} not found", post_id)]
    PostNotFound { post_id: PostId },
    #[display(fmt = "Missing param '{}' for new thread", param)]
    MissingThreadParam { param: String },
    #[display(fmt = "Missing param '{}' for new post", param)]
    MissingPostParam { param: String },
    #[display(fmt = "Couldn't parse multipart/form-data")]
    FormDataCouldntParse,
    #[display(fmt = "Bad Content-Type for multipart/form-data")]
    FormDataBadContentType,
    #[display(fmt = "The password is not correct")]
    PasswordError,
    #[display(fmt = "Deleting files only is not a valid option for threads")]
    CannotDeleteThreadFilesOnly,
    #[display(fmt = "Couldn't create regex: {}", _0)]
    #[from]
    RegexError(regex::Error),
    #[display(fmt = "Error processing image: {}", _0)]
    #[from]
    ImageError(image::error::ImageError),
    #[display(fmt = "Couldn't hash password: {}", _0)]
    #[from]
    HashError(argon2::Error),
    #[display(fmt = "Couldn't render HTML template: {}", _0)]
    #[from]
    RenderError(handlebars::RenderError),
    #[display(fmt = "JSON error: {}", _0)]
    #[from]
    JsonError(serde_json::error::Error),
    #[display(fmt = "YAML error: {}", _0)]
    #[from]
    YamlError(serde_yaml::Error),
    #[display(fmt = "HTML template file error: {}", _0)]
    #[from]
    TemplateError(handlebars::TemplateFileError),
    #[display(fmt = "Couldn't initialize logging: {}", _0)]
    #[from]
    LogError(log::SetLoggerError),
    #[display(fmt = "Database connection pool error: {}", _0)]
    #[from]
    R2d2Error(r2d2::Error),
    #[display(fmt = "Database error: {}", _0)]
    #[from]
    DatabaseError(diesel::result::Error),
    #[display(fmt = "Couldn't connect to the PostgreSQL database: {}", _0)]
    #[from]
    ConnectionError(diesel::ConnectionError),
    #[display(fmt = "I/O error: {}", _0)]
    #[from]
    IoError(std::io::Error),
    #[display(fmt = "I/O error: {}: {}", msg, cause)]
    IoErrorMsg { cause: std::io::Error, msg: String },
}

impl Error {
    fn from_io_error<S>(cause: std::io::Error, msg: S) -> Error
    where
        S: Into<String>,
    {
        Error::IoErrorMsg {
            cause,
            msg: msg.into(),
        }
    }
}

impl<'r> Responder<'r> for Error {
    fn respond_to(self, req: &Request) -> rocket::response::Result<'r> {
        match self {
            Error::MissingThreadParam { .. }
            | Error::MissingPostParam { .. }
            | Error::ImageError(..)
            | Error::PasswordError => {
                warn!("{}", &self);

                let template = Template::render(
                    "layout/error/400",
                    hashmap! {
                        "message" => self.to_string()
                    },
                );

                let mut res = template.respond_to(req)?;
                res.set_status(Status::BadRequest);

                Ok(res)
            }

            Error::BoardNotFound { .. } | Error::ThreadNotFound { .. } => {
                warn!("{}", &self);

                let template = Template::render(
                    "layout/error/404",
                    hashmap! {
                        "message" => self.to_string()
                    },
                );

                let mut res = template.respond_to(req)?;
                res.set_status(Status::NotFound);

                Ok(res)
            }

            _ => {
                error!("{}", self);

                let template = Template::render("layout/error/500", ());

                let mut res = template.respond_to(req)?;
                res.set_status(Status::InternalServerError);

                Ok(res)
            }
        }
    }
}

impl std::error::Error for Error {}

/// Our result type.
pub type Result<T> = std::result::Result<T, Error>;

/// A rocket fairing for logging about requests.
pub struct LogFairing;

impl Fairing for LogFairing {
    fn info(&self) -> Info {
        Info {
            name: "Logging Fairing",
            kind: Kind::Launch | Kind::Response,
        }
    }

    fn on_launch(&self, rocket: &Rocket) {
        let conf = rocket.config();

        info!("Starting on {}:{}", conf.address, conf.port);
    }

    fn on_response(&self, request: &Request, response: &mut Response) {
        let mut msg = String::new();

        match request.client_ip() {
            Some(ip) => write!(msg, "[{}]", ip).unwrap(),
            None => write!(msg, "[Unknown]").unwrap(),
        }

        write!(msg, " {}", request.method()).unwrap();
        write!(msg, " {}", request.uri().to_string()).unwrap();
        write!(msg, " {}", response.status()).unwrap();

        if let Some(content_type) = response.content_type() {
            write!(msg, " ({})", content_type).unwrap();
        }

        if let Some(referer) = request.headers().get_one("Referer") {
            write!(msg, " Referer \"{}\"", referer).unwrap();
        }

        if let Some(user_agent) = request.headers().get_one("User-Agent") {
            write!(msg, " User-Agent \"{}\"", user_agent).unwrap();
        }

        if let StatusClass::ClientError | StatusClass::ServerError = response.status().class() {
            warn!("{}", msg);
        } else {
            info!("{}", msg);
        }
    }
}
